<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BADMINTON - 8-BIT Style</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <style>
        /* 2. 中文像素字體 (說明用) */
        @font-face {
            font-family: 'Cubic 11';
            src: url('https://cdn.jsdelivr.net/gh/ACh-K/Cubic-11@1.100/fonts/ttf/Cubic_11_1.100_R.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        :root {
            /* 1P = 紅色, 2P = 藍色 */
            --color-1p-main: #D32F2F; 
            --color-1p-light: #FF5252;
            
            --color-2p-main: #1976D2; 
            --color-2p-light: #448AFF;
            
            --color-txt-left: var(--color-1p-light);
            --color-txt-right: var(--color-2p-light);
            
            --font-main: 'Press Start 2P', 'Cubic 11', cursive;
            
            --score-size-normal: 12vw; 
            --score-size-huge: 20vw; 

            /* 統一圓角與陰影 */
            --ui-radius: 15px;
            --ui-border: 4px solid #fff;
            --ui-shadow: 6px 6px 0px rgba(0, 0, 0, 1); /* 實心黑陰影 */
        }

        * { box-sizing: border-box; }

        body { 
            margin: 0; 
            background-color: #1a1a1a; 
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            color: #fff; 
            font-family: var(--font-main);
            overflow: hidden; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            user-select: none; touch-action: none; 
        }

        /* 閃爍轉場遮罩 */
        #flash-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 99999;
            opacity: 0; pointer-events: none; display: none;
        }
        #flash-overlay.active {
            display: block;
            animation: flash-anim 0.2s ease-out 4; /* 閃爍4次 */
        }
        @keyframes flash-anim {
            0% { opacity: 0; }
            50% { opacity: 0.1; }
            100% { opacity: 0; }
        }

        /* 凍結操作遮罩 */
        #input-blocker {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 99998; display: none; cursor: wait;
        }

        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 9999;
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
        }

        #portrait-lock {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9000; display: none; 
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px;
        }
        .lock-title { font-size: 2rem; line-height: 1.5; margin-bottom: 20px; color: #fff; text-shadow: 4px 4px 0 #333; }
        .rotate-icon {
            width: 80px; height: 120px; border: 6px solid #fff; border-radius: 15px;
            animation: rotate-anim 2s infinite steps(4); margin-bottom: 30px; position: relative;
            background: transparent; box-shadow: 8px 8px 0 #000;
        }
        .rotate-icon::before {
            content: ''; position: absolute; top: 15px; left: 50%; transform: translateX(-50%); 
            width: 8px; height: 8px; background: #fff; border-radius: 50%;
        }
        .lock-subtitle { font-size: 1rem; opacity: 0.8; line-height: 1.5; color: #ddd; }
        @keyframes rotate-anim { 0% { transform: rotate(0deg); } 40% { transform: rotate(90deg); } 100% { transform: rotate(90deg); } }
        
        @media screen and (orientation: portrait) {
            body.require-landscape #portrait-lock { display: flex; }
            body.require-landscape #game-container, 
            body.require-landscape #server-select-screen { display: none !important; }
        }

        #start-screen, #server-select-screen, #winner-screen, #name-input-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 5000;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; 
            overflow-y: auto; overflow-x: hidden; padding: 20px;
        }
        #server-select-screen, #winner-screen, #name-input-screen { display: none; } 

        .start-container { text-align: center; width: 95%; max-width: 700px; padding: 20px; }
        .main-title {
            font-size: clamp(2rem, 6vw, 4rem); line-height: 1.2; color: #FFFF00;
            margin: 0 0 20px 0; text-shadow: 6px 6px 0px #D32F2F;
        }
        .sub-title {
            display: block; font-size: 1rem; margin-top: 15px; margin-bottom: 40px; 
            color: #fff; text-shadow: 2px 2px 0 #000;
        }
        .txt-score { color: var(--color-1p-light); text-shadow: 2px 2px 0 #000; }
        .txt-board { color: var(--color-2p-light); text-shadow: 2px 2px 0 #000; }

        .ai-toggle-container {
            margin-top: 30px; display: flex; align-items: center; justify-content: center; gap: 15px;
            padding: 10px; background: #000;
            border: var(--ui-border); border-radius: var(--ui-radius);
            box-shadow: var(--ui-shadow);
        }
        .ai-label { font-size: 1rem; color: #fff; }
        .switch { position: relative; display: inline-block; width: 60px; height: 30px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #555; transition: 0s; border: 2px solid #fff; border-radius: 30px;
        }
        .slider:before {
            position: absolute; content: ""; height: 20px; width: 20px; left: 2px; bottom: 3px;
            background-color: white; transition: 0s; border-radius: 50%; box-shadow: 1px 1px 0 #000;
        }
        input:checked + .slider { background-color: var(--color-2p-main); }
        input:checked + .slider:before { transform: translateX(30px); }

        #ai-warning-modal, #tutorial-modal, #settings-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 8000;
            display: none; justify-content: center; align-items: center; padding: 20px;
        }
        .modal-box {
            background: #000080; border: var(--ui-border); 
            padding: 30px 20px; border-radius: var(--ui-radius); text-align: center;
            max-width: 600px; width: 100%; box-shadow: 10px 10px 0px #000;
            max-height: 90vh; overflow-y: auto;
        }
        #tutorial-modal .modal-box { background: #000; }

        .modal-title {
            font-size: 1.5rem; color: #FFFF00; margin-bottom: 25px; text-transform: uppercase;
            text-shadow: 3px 3px 0 #000; border-bottom: 2px dashed #fff; padding-bottom: 15px;
        }
        .modal-text {
            font-size: 1.2rem; color: #fff; line-height: 1.8; margin-bottom: 30px; text-align: left;
        }
        #tutorial-list { padding: 0; list-style: none; margin: 0 0 30px 0; text-align: left; padding-left: 20px; }
        #tutorial-list li { margin-bottom: 15px; position: relative; }
        #tutorial-list li::before { content: ">"; position: absolute; left: -20px; color: yellow; }
        #tutorial-list li strong { color: #00FF00; }

        .modal-buttons { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        
        /* --- 通用按鈕樣式 (圓角 + 陰影) --- */
        .modal-btn, .btn-mode, .btn-nav, .btn, .btn-settings {
            font-family: var(--font-main); 
            background: #000; color: #fff; 
            cursor: pointer; 
            text-transform: uppercase; position: relative;
            border: var(--ui-border); 
            border-radius: var(--ui-radius);
            box-shadow: var(--ui-shadow);
            transition: transform 0.05s; 
        }
        
        .modal-btn:active, .btn-mode:active, .btn-nav:active, .btn:active, .btn-settings:active, .select-zone:active {
            transform: translate(4px, 4px);
            box-shadow: 2px 2px 0px rgba(0,0,0,1);
        }
        
        .modal-btn { padding: 15px 20px; font-size: 1rem; min-width: 120px; }
        .btn-cancel { border-color: #999; color: #ccc; }
        .btn-confirm { border-color: #fff; color: #FFFF00; }
        
        .mode-btn-container { display: flex; gap: 20px; justify-content: center; width: 100%; flex-wrap: wrap; margin-bottom: 20px; }
        .btn-mode { flex: 1; min-width: 180px; font-size: 1.5rem; padding: 25px 10px; }
        
        /* 1P: 紅框白字 */
        #btn-mode-1p { border-color: var(--color-1p-main); color: #fff; }
        #btn-mode-1p:hover { background: var(--color-1p-main); }
        
        /* 2P: 藍框白字 */
        #btn-mode-2p { border-color: var(--color-2p-main); color: #fff; }
        #btn-mode-2p:hover { background: var(--color-2p-main); }

        .settings-row {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 25px; border-bottom: 2px dashed rgba(255,255,255,0.3); padding-bottom: 15px;
        }
        .settings-label { font-size: 1rem; text-align: left; width: 45%; color: #fff; }
        .settings-control { width: 50%; display: flex; justify-content: flex-end; align-items: center; }
        
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 24px; width: 12px; background: #FFFF00; 
            margin-top: -8px; cursor: pointer; border-radius: 4px;
            border: 2px solid #000; box-shadow: 2px 2px 0 #000;
        }
        input[type=range]::-webkit-slider-runnable-track { 
            width: 100%; height: 8px; cursor: pointer; background: #fff; 
            border: 2px solid #000; border-radius: 4px;
        }
        .val-display { font-size: 1rem; margin-left: 10px; width: 50px; text-align: right; color: #FFFF00; }

        #name-inputs-wrapper { display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; width: 100%; max-width: 1000px; }
        .team-input-col { 
            display: flex; flex-direction: column; gap: 15px; align-items: center; width: 100%; flex: 1; 
            background: rgba(0,0,0,0.5); padding: 20px; 
            border: var(--ui-border); border-radius: var(--ui-radius); box-shadow: var(--ui-shadow);
        }
        .team-input-col:first-child .team-title { color: var(--color-1p-light); }
        .team-input-col:last-child .team-title { color: var(--color-2p-light); }
        .team-title { font-size: 1.2rem; margin-bottom: 10px; text-shadow: 2px 2px 0 #000; }
        
        .input-wrapper { position: relative; width: 100%; display: flex; flex-direction: column; align-items: center; }
        .input-box {
            background: #000; color: #FFFF00; font-family: var(--font-main); font-size: 1rem; 
            width: 100%; max-width: 300px; text-align: center; padding: 15px 45px 15px 45px; 
            text-transform: uppercase; outline: none; transition: all 0.1s; 
            border: var(--ui-border); border-radius: var(--ui-radius); box-shadow: 4px 4px 0 #000;
        }
        .input-box:focus { background: #222; }
        .kb-icon {
            position: absolute; right: 15px; top: 15px; /* Fixed pos relative to input */
            width: 24px; height: 24px; display: none; cursor: pointer; z-index: 50; 
        }
        .kb-icon.show { display: flex; }
        .kb-icon svg { width: 100%; height: 100%; fill: #fff; shape-rendering: crispEdges; }

        @media screen and (orientation: landscape) {
            #name-inputs-wrapper { flex-direction: row; align-items: flex-start; }
            #name-input-screen { justify-content: center; } 
        }
        @media screen and (orientation: portrait) {
            #name-inputs-wrapper { flex-direction: column; align-items: stretch; }
            #name-input-screen { justify-content: center; padding-top: 0px; }
            .team-input-col { width: 100%; }
        }

        /* --- 下拉選單樣式 (限制高度 + 側邊把手) --- */
        .history-dropdown {
            position: absolute; top: 100%; left: 50%; transform: translateX(-50%); width: 100%; max-width: 300px;
            background: #000; border-top: none; z-index: 100;
            max-height: 260px; overflow-y: auto; 
            display: none; flex-direction: column; 
            border: 4px solid #fff; border-bottom-left-radius: 15px; border-bottom-right-radius: 15px;
            box-shadow: 6px 6px 0 #000;
        }
        .history-dropdown::-webkit-scrollbar {
            width: 14px; 
            background: #000;
            border-left: 2px solid #fff;
        }
        .history-dropdown::-webkit-scrollbar-thumb {
            background-color: #FFFF00; 
            border: 2px solid #000;
            border-radius: 0;
            box-shadow: inset 1px 1px 0 #fff;
        }
        .history-dropdown::-webkit-scrollbar-track {
            background: #222;
        }

        .history-dropdown.show { display: flex; }
        .history-item { 
            padding: 15px; color: #fff; font-size: 1rem; text-align: center; cursor: pointer; border-bottom: 2px solid #333; flex-shrink: 0;
        }
        .history-item:hover { background: #fff; color: #000; }
        .history-item.deleting { background: #ff0000; color: #fff; }

        .nav-btn-container { display: flex; gap: 20px; justify-content: center; width: 100%; flex-wrap: wrap; margin-top: 0px; padding-bottom: 20px;}
        .btn-nav {
            font-size: 1.2rem; padding: 15px 30px; background: #000; min-width: 160px;
        }
        .btn-nav:hover { background: #333; color: #FFFF00; }

        #server-select-screen {
            justify-content: center;
            align-items: center; 
            display: none; 
            flex-direction: column; 
        }
        .select-hint { 
            position: static; 
            margin-bottom: 20px; 
            width: auto; 
            text-align: center; font-size: 1.5rem; 
            pointer-events: none; color: #fff; background: #000; padding: 10px 20px; 
            border: var(--ui-border); border-radius: var(--ui-radius); box-shadow: var(--ui-shadow);
        }
        .split-select { 
            display: flex; width: 100%; 
            flex: 1; 
            max-height: 60vh; 
            margin-bottom: 20px; 
            border: var(--ui-border);
            border-radius: var(--ui-radius);
            box-shadow: var(--ui-shadow);
            overflow: hidden; 
        }
        #server-back-btn { 
            position: static; 
            transform: none; 
            z-index: 20; 
        }

        @media screen and (orientation: portrait) { 
            .split-select { flex-direction: column; } 
            .select-zone { width: 100% !important; height: 50% !important; font-size: 2.5rem !important; }
        }
        .select-zone {
            width: 50%; height: 100%; display: flex; justify-content: center; align-items: center;
            font-size: 4rem; cursor: pointer; transition: background 0.1s;
        }
        /* 左側紅 */
        .zone-left { 
            background: #000; color: var(--color-1p-light); 
            border-right: 2px solid #fff; text-shadow: 4px 4px 0 #000; 
        }
        .zone-left:hover { background: #300; }
        /* 右側藍 */
        .zone-right { 
            background: #000; color: var(--color-2p-light); 
            border-left: 2px solid #fff; text-shadow: 4px 4px 0 #000; 
        }
        .zone-right:hover { background: #003; }

        #winner-text { 
            font-size: 8vw; color: #FFFF00; text-shadow: 8px 8px 0px #000; margin-bottom: 40px; text-align: center; line-height: 1.5;
        }
        #btn-restart { 
            font-size: 1.5rem; background: #000; color: #fff; padding: 20px 40px; cursor: pointer; 
        }

        #game-container { position: relative; width: 100%; height: 100%; transition: none; background: #000; display: none; }
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); transition: opacity 0.5s ease; }
        body.mode-blackout video { opacity: 0; }

        .side-bar-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .side-bar { position: absolute; width: 12px; height: 48%; background: transparent; transition: all 0.1s; opacity: 0.2; }
        #bar-left-top { top: 1%; left: 1%; border: 2px dashed #fff; border-bottom-right-radius: 10px; }
        #bar-left-bottom { bottom: 1%; left: 1%; border: 2px dashed #fff; border-top-right-radius: 10px; }
        #bar-right-top { top: 1%; right: 1%; border: 2px dashed #fff; border-bottom-left-radius: 10px; }
        #bar-right-bottom { bottom: 1%; right: 1%; border: 2px dashed #fff; border-top-left-radius: 10px; }
        .bar-active { opacity: 1; background-color: var(--bar-color); border-style: solid; box-shadow: 4px 4px 0 #000; width: 20px; }
        .bar-partner { opacity: 0.5; background-color: var(--bar-color); border-style: dotted; width: 12px; }

        .name-label {
            position: absolute; font-size: 1.5rem; color: #fff; text-shadow: 3px 3px 0 #000; 
            z-index: 15; pointer-events: none; text-transform: uppercase; opacity: 0; transition: opacity 0.2s;
            background: rgba(0,0,0,0.6); padding: 5px;
            border: 2px solid #fff; border-radius: 8px; box-shadow: 4px 4px 0 #000;
        }
        .name-visible { opacity: 1; }
        
        /* 姓名標籤緊貼四個角落 */
        #name-lt { top: 20px; left: 20px; }
        #name-lb { bottom: 20px; left: 20px; }
        #name-rt { top: 20px; right: 20px; }
        #name-rb { bottom: 20px; right: 20px; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: center; }
        #bottom-controls { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); pointer-events: auto; z-index: 20; 
            display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; width: 95%; transition: opacity 0.5s ease; opacity: 0;
        }
        .controls-visible #bottom-controls { opacity: 1; }
        #serve-arrow-svg { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            width: 80px; height: 80px; opacity: 0; transition: all 0.1s; z-index: 100; filter: drop-shadow(4px 4px 0px #000); 
        }
        .svg-arrow-left { fill: var(--color-1p-light); transform: translate(-50%, -50%) rotate(180deg) !important; opacity: 1 !important; }
        .svg-arrow-right { fill: var(--color-2p-light); transform: translate(-50%, -50%) rotate(0deg) !important; opacity: 1 !important; }

        .btn { 
            background: #000; color: #fff; padding: 10px 15px; font-size: 0.8rem; letter-spacing: 1px; 
            backdrop-filter: none; 
        }
        .btn:hover { background: #fff; color: #000; }
        #btn-exit:hover { background: #ff0000; color: #fff; }
        .btn-settings { font-size: 1rem; padding: 15px 30px; margin-top: 30px; background: #000; }
        .btn-settings:hover { background: #222; border-color: #FFFF00; color: #FFFF00; }

        /* --- 修正：絕對固定位置的分數 --- */
        .scoreboard-row { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 100%; height: 100%; 
            position: relative; /* 確保內部絕對定位參考 */
        }
        body.mode-blackout .scoreboard-row { padding: 0 20px; }
        
        .score-group { 
            display: flex; flex-direction: column; align-items: center; 
            /* 強制設定為 50% 寬度，讓左邊永遠在左半，右邊永遠在右半 */
            width: 50%; 
            flex: 1;
            height: 80%; justify-content: center; position: relative; pointer-events: auto; border: none; cursor: ns-resize; 
        }
        .score-num { 
            font-size: var(--score-size-normal); line-height: 1; transition: font-size 0.2s; z-index: 1; pointer-events: none; 
            font-family: var(--font-main);
            text-align: center;
        }
        body.mode-blackout .score-num { font-size: var(--score-size-huge); }
        
        #lbl-left { color: var(--color-1p-light); }
        #score-left { color: transparent; -webkit-text-stroke: 2px var(--color-1p-light); }
        #score-left.has-score { color: var(--color-1p-light); -webkit-text-stroke: 0; text-shadow: 8px 8px 0 #000; }
        #lbl-right { color: var(--color-2p-light); }
        #score-right { color: transparent; -webkit-text-stroke: 2px var(--color-2p-light); }
        #score-right.has-score { color: var(--color-2p-light); -webkit-text-stroke: 0; text-shadow: 8px 8px 0 #000; }
        .score-pop { animation: bump 0.1s steps(2); }
        @keyframes bump { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 99; display: none; flex-direction: column; justify-content: center; align-items: center; }
        .spinner { 
            width: 40px; height: 40px; background: #FFFF00; animation: flip 1s infinite steps(4); 
            margin-bottom: 20px; border: 4px solid #fff; border-radius: 50%;
        }
        #loading-text { font-size: 1rem; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        @keyframes flip { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="flash-overlay"></div>
    <div id="input-blocker"></div>

    <div id="portrait-lock">
        <div class="lock-title">BADMINTON<br>8-BIT</div>
        <div class="rotate-icon"></div>
        <div class="lock-subtitle">請旋轉裝置<br>連點啟動全螢幕</div>
        <br>
        <button class="btn-nav btn-back" onclick="performTransition(handleLockBack)">BACK</button>
    </div>

    <div id="ai-warning-modal">
        <div class="modal-box">
            <div class="modal-title">WARNING</div>
            <div class="modal-text">
                動作捕捉計分系統測試中，<br>
                遊戲過程中可能發生閃退。
            </div>
            <div class="modal-buttons">
                <button class="modal-btn btn-cancel btn-back" onclick="cancelAI()">CANCEL</button>
                <button class="modal-btn btn-confirm" onclick="confirmAI()">CONFIRM</button>
            </div>
        </div>
    </div>

    <div id="tutorial-modal">
        <div class="modal-box">
            <div class="modal-title" id="tutorial-title">GAME TUTORIAL</div>
            <ul class="modal-text" id="tutorial-list"></ul>
            <div class="modal-buttons">
                <button class="modal-btn btn-cancel btn-back" onclick="performTransition(backFromTutorial)">BACK</button>
                <button class="modal-btn btn-confirm" onclick="performTransition(closeTutorial)">START</button>
            </div>
        </div>
    </div>
    
    <div id="settings-modal">
        <div class="modal-box">
            <div class="modal-title">SETTINGS</div>
            
            <div class="settings-row">
                <div class="settings-label">VOLUME</div>
                <div class="settings-control">
                    <input type="range" id="set-volume" min="0" max="1" step="0.1">
                    <span class="val-display" id="val-volume">1.0</span>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">SPEED</div>
                <div class="settings-control">
                    <input type="range" id="set-rate" min="0.5" max="2" step="0.1">
                    <span class="val-display" id="val-rate">1.2</span>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">DEFAULT CAM</div>
                <div class="settings-control">
                      <label class="switch">
                        <input type="checkbox" id="set-cam-default">
                        <span class="slider"></span>
                      </label>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">DEFAULT NAMES</div>
                <div class="settings-control">
                      <label class="switch">
                        <input type="checkbox" id="set-name-default">
                        <span class="slider"></span>
                      </label>
                </div>
            </div>

            <div class="modal-buttons" style="margin-top: 30px;">
                <button class="modal-btn btn-confirm" onclick="saveAndCloseSettings()">SAVE</button>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div class="start-container">
            <h1 class="main-title">
                BADMINTON
                <span class="sub-title">
                    <span class="txt-score">SCORE</span><span class="txt-board">BOARD</span>
                </span>
            </h1>
            <div class="mode-btn-container">
                <button id="btn-mode-1p" class="btn-mode" onclick="performTransition(() => selectMode('singles'))">1P SINGLES</button>
                <button id="btn-mode-2p" class="btn-mode" onclick="performTransition(() => selectMode('doubles'))">2P DOUBLES</button>
            </div>
            
            <div class="ai-toggle-container">
                <span class="ai-label">AI ASSIST</span>
                <label class="switch">
                    <input type="checkbox" id="ai-toggle-checkbox">
                    <span class="slider"></span>
                </label>
            </div>

            <button class="btn-settings" onclick="openSettings()">OPTIONS</button>
        </div>
    </div>

    <div id="name-input-screen">
        <div style="font-size: 1.2rem; margin-bottom: 20px; color:#FFFF00; text-shadow: 2px 2px 0 #000;">PLAYER ENTRY</div>
        <div id="name-inputs-wrapper"></div>
        <div class="nav-btn-container">
            <button class="btn-nav btn-back" onclick="performTransition(goBackToStart)">BACK</button>
            <button class="btn-nav" onclick="performTransition(submitNames)">READY</button>
        </div>
    </div>

    <div id="server-select-screen">
        <div class="select-hint">WHO SERVES FIRST?</div>
        <div class="split-select">
            <div class="select-zone zone-left" onclick="performTransition(() => initSystem('left'))">LEFT<br>TEAM</div>
            <div class="select-zone zone-right" onclick="performTransition(() => initSystem('right'))">RIGHT<br>TEAM</div>
        </div>
        <button id="server-back-btn" class="btn-nav btn-back" onclick="performTransition(goBackToNameInput)">BACK</button>
    </div>

    <div id="winner-screen">
        <div id="winner-text">PLAYER WINS!</div>
        <button id="btn-restart" class="btn-back" onclick="performTransition(exitGame)">INSERT COIN</button>
    </div>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">LOADING...</div>
    </div>

    <div id="game-container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="output"></canvas>

        <div class="side-bar-container">
            <div id="bar-left-top" class="side-bar"></div>
            <div id="bar-left-bottom" class="side-bar"></div>
            <div id="bar-right-top" class="side-bar"></div>
            <div id="bar-right-bottom" class="side-bar"></div>
        </div>

        <div id="name-labels-layer">
            <div id="name-lt" class="name-label"></div>
            <div id="name-lb" class="name-label"></div>
            <div id="name-rt" class="name-label"></div>
            <div id="name-rb" class="name-label"></div>
        </div>

        <div id="ui-layer">
            <svg id="serve-arrow-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M 20,20 L 80,50 L 20,80 Z" stroke-linejoin="miter" stroke="#fff" stroke-width="4" />
            </svg>
            
            <div id="top-controls"></div>

            <div class="scoreboard-row">
                <div class="score-group" id="group-left">
                    <div id="score-left" class="score-num">0</div>
                </div>
                <div class="score-group" id="group-right">
                    <div id="score-right" class="score-num">0</div>
                </div>
            </div>

            <div id="bottom-controls">
                <button class="btn" onclick="resetScores()">RESET</button>
                <button class="btn" id="btn-names" onclick="toggleNames()">NAMES</button>
                <button class="btn" id="btn-cam" onclick="toggleCamera()">CAM</button>
                <button class="btn" onclick="changeServerSide()">SERVE</button>
                <button class="btn btn-back" id="btn-exit" onclick="performTransition(exitGame)">EXIT</button>
            </div>
        </div>
    </div>

    <script>
        // --- 設定與變數 ---
        let gameSettings = {
            volume: 1.0,
            rate: 1.2,
            defaultCam: true,
            defaultNames: true
        };

        const SETTINGS_KEY = 'badminton_settings_pixel';
        const savedSettings = localStorage.getItem(SETTINGS_KEY);
        if (savedSettings) {
            try {
                gameSettings = { ...gameSettings, ...JSON.parse(savedSettings) };
            } catch(e) {}
        }
        
        // --- Audio Manager ---
        const sounds = {
            select: new Audio('select.mp3'),
            on: new Audio('on.mp3'),
            cancel: new Audio('cancel.mp3'),
            back: new Audio('back.mp3'),
            start: new Audio('start.mp3'),
            red: new Audio('red.mp3'),
            blue: new Audio('blue.mp3')
        };
        
        function playSound(key) {
            if(gameSettings.volume > 0 && sounds[key]) {
                const s = sounds[key].cloneNode(); 
                s.volume = gameSettings.volume;
                s.play().catch(()=>{});
            }
        }
        
        // --- Global Back Sound Listener (Backup) ---
        document.addEventListener('click', (e) => {
            const target = e.target.closest('button') || e.target;
            if (target.classList && target.classList.contains('btn-back')) {
                // Sound logic now handled in performTransition usually, but double safety
            }
        });

        // --- Transition Logic (Menu Switching) ---
        function performTransition(callback) {
            // 1. Determine Sound (Simple check: is it a back button?)
            // We use Event target check if triggered by click
            let isBack = false;
            if(event && event.target) {
                const target = event.target.closest('button') || event.target;
                if(target.innerText === 'BACK' || target.innerText === 'EXIT' || target.innerText === 'CANCEL' || target.classList.contains('btn-back')) {
                    isBack = true;
                }
            }
            playSound(isBack ? 'back' : 'select');

            // 2. Block Input
            const blocker = document.getElementById('input-blocker');
            blocker.style.display = 'block';

            // 3. Flicker Effect
            const overlay = document.getElementById('flash-overlay');
            overlay.classList.add('active');

            // 4. Wait 1 Second then execute Callback
            setTimeout(() => {
                if(callback) callback();
                
                // Cleanup
                overlay.classList.remove('active');
                blocker.style.display = 'none';
            }, 699);
        }

        const video = document.getElementById('video');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        const loader = document.getElementById('loader');
        const statusText = document.getElementById('loading-text');
        
        const startScreen = document.getElementById('start-screen');
        const nameInputScreen = document.getElementById('name-input-screen');
        const selectScreen = document.getElementById('server-select-screen');
        const winnerScreen = document.getElementById('winner-screen');
        const gameContainer = document.getElementById('game-container');
        const uiLayer = document.getElementById('ui-layer');
        const settingsModal = document.getElementById('settings-modal');
        
        const btnCam = document.getElementById('btn-cam');
        const btnNames = document.getElementById('btn-names');
        const arrowSvg = document.getElementById('serve-arrow-svg');
        const bodyEl = document.body;
        const winnerText = document.getElementById('winner-text');
        const aiCheckbox = document.getElementById('ai-toggle-checkbox');
        
        const warningModal = document.getElementById('ai-warning-modal');
        const tutorialModal = document.getElementById('tutorial-modal');
        const tutorialTitle = document.getElementById('tutorial-title');
        const tutorialList = document.getElementById('tutorial-list');

        // Settings Elements
        const elVol = document.getElementById('set-volume');
        const valVol = document.getElementById('val-volume');
        const elRate = document.getElementById('set-rate');
        const valRate = document.getElementById('val-rate');
        const elCamDef = document.getElementById('set-cam-default');
        const elNameDef = document.getElementById('set-name-default');

        const bars = {
            lt: document.getElementById('bar-left-top'),
            lb: document.getElementById('bar-left-bottom'),
            rt: document.getElementById('bar-right-top'),
            rb: document.getElementById('bar-right-bottom')
        };

        const nameLabels = {
            lt: document.getElementById('name-lt'),
            lb: document.getElementById('name-lb'),
            rt: document.getElementById('name-rt'),
            rb: document.getElementById('name-rb')
        };

        let detector;
        let rafId;
        const WIN_SCORE = 21; const MAX_SCORE = 30;
        let scores = { left: 0, right: 0 };
        let holdStart = 0; let isHolding = false;
        const HOLD_DURATION = 1500; 
        const COOLDOWN_DURATION = 3; 
        let cooldownTimer = 0; let cooldownInterval = null;
        let isCamVisible = true; let isModelLoaded = false; 
        let isGameActive = false; let currentServer = null; 
        let gameMode = 'singles'; let isAIMode = false; 
        let leftPositions = [1, 2]; let rightPositions = [1, 2];
        let areNamesVisible = true; 
        let controlsTimer = null; 
        let tempSelectedMode = '';
        let smoothX = 0; let smoothY = 0;

        let appSettings = { width: 480, height: 360, fps: 15 };
        
        const STORAGE_KEY = 'badminton_player_names';
        let historyList = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
        let playerNames = { l1: "", l2: "", r1: "", r2: "" };

        let wakeLock = null;
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) { console.error(err); }
        }
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') { await requestWakeLock(); }
        });

        // --- Settings Logic ---
        function openSettings() {
            playSound('select'); 
            elVol.value = gameSettings.volume;
            valVol.innerText = gameSettings.volume;
            elRate.value = gameSettings.rate;
            valRate.innerText = gameSettings.rate;
            elCamDef.checked = gameSettings.defaultCam;
            elNameDef.checked = gameSettings.defaultNames;
            settingsModal.style.display = 'flex';
        }

        function saveAndCloseSettings() {
            playSound('select'); 
            gameSettings.volume = parseFloat(elVol.value);
            gameSettings.rate = parseFloat(elRate.value);
            gameSettings.defaultCam = elCamDef.checked;
            gameSettings.defaultNames = elNameDef.checked;
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
            settingsModal.style.display = 'none';
        }

        elVol.addEventListener('input', (e) => valVol.innerText = e.target.value);
        elRate.addEventListener('input', (e) => valRate.innerText = e.target.value);

        // --- TTS Voice Finder ---
        function getPreferredVoice() {
            const voices = window.speechSynthesis.getVoices();
            let target = voices.find(v => (v.lang.includes('zh') || v.lang.includes('CN') || v.lang.includes('TW')) && 
                (v.name.includes('Google') || v.name.includes('Meijia') || v.name.includes('Yating') || v.name.includes('Siri') || v.name.includes('Sinji') || v.name.includes('Ting-Ting')));
            
            if (!target) target = voices.find(v => (v.lang.includes('zh') || v.lang.includes('CN') || v.lang.includes('TW')) && v.name.toLowerCase().includes('female'));
            if (!target) target = voices.find(v => v.lang.includes('zh') || v.lang.includes('CN') || v.lang.includes('TW'));
            return target;
        }
        window.speechSynthesis.getVoices();

        // --- AI Toggle Logic ---
        aiCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                playSound('on'); 
                warningModal.style.display = 'flex';
            } else {
                playSound('cancel'); 
                isAIMode = false;
            }
        });

        function confirmAI() {
            playSound('select'); 
            warningModal.style.display = 'none';
            isAIMode = true;
        }

        function cancelAI() {
            playSound('back');
            warningModal.style.display = 'none';
            aiCheckbox.checked = false;
            isAIMode = false;
        }

        // --- 1. 流程 ---

        function selectMode(mode) {
            tempSelectedMode = mode;
            if (isAIMode) {
                tutorialTitle.innerText = "AI MODE";
                tutorialList.innerHTML = `
                    <li>1. 站在鏡頭前，全身入鏡。</li>
                    <li>2. 舉手兩秒即可感應得分。</li>
                    <li>3. 舉起左手，左方得分。</li>
                    <li>4. 舉起右手，右方得分。</li>`;
            } else {
                tutorialTitle.innerText = "MANUAL MODE";
                tutorialList.innerHTML = `
                    <li>1. 滑動左右方分數計分。</li>
                    <li>2. 上滑畫面 +1 分。</li>
                    <li>3. 下滑畫面 -1 分。</li>`;
            }
            startScreen.style.display = 'none';
            tutorialModal.style.display = 'flex';
        }

        function closeTutorial() {
            tutorialModal.style.display = 'none';
            goToNameInput(tempSelectedMode);
        }
        
        function backFromTutorial() {
            tutorialModal.style.display = 'none';
            startScreen.style.display = 'flex';
        }

        function goToNameInput(mode) {
            gameMode = mode;
            nameInputScreen.style.display = 'flex';
            bodyEl.classList.remove('require-landscape');
            generateNameInputs();
        }

        function goBackToStart() {
            nameInputScreen.style.display = 'none';
            startScreen.style.display = 'flex';
        }

        function goBackToNameInput() {
            selectScreen.style.display = 'none';
            nameInputScreen.style.display = 'flex';
            bodyEl.classList.remove('require-landscape');
        }
        
        function handleLockBack() {
            if (selectScreen.style.display === 'block' || selectScreen.style.display === 'flex' || gameContainer.style.display === 'block') {
                if (gameContainer.style.display === 'block') {
                    exitGame();
                    startScreen.style.display = 'none';
                    nameInputScreen.style.display = 'flex';
                } else {
                    goBackToNameInput();
                }
            } else {
                goBackToStart();
            }
        }

        function generateNameInputs() {
            const wrapper = document.getElementById('name-inputs-wrapper');
            wrapper.innerHTML = '';

            const leftCol = document.createElement('div');
            leftCol.className = 'team-input-col';
            leftCol.innerHTML = `<div class="team-title">LEFT TEAM</div>`;
            
            const l1Input = createInput('L1', 'P1 NAME');
            leftCol.appendChild(l1Input);
            
            if (gameMode === 'doubles') {
                const l2Input = createInput('L2', 'P2 NAME');
                leftCol.appendChild(l2Input);
            }
            wrapper.appendChild(leftCol);

            const rightCol = document.createElement('div');
            rightCol.className = 'team-input-col';
            rightCol.innerHTML = `<div class="team-title">RIGHT TEAM</div>`;
            
            const r1Input = createInput('R1', 'P1 NAME');
            rightCol.appendChild(r1Input);

            if (gameMode === 'doubles') {
                const r2Input = createInput('R2', 'P2 NAME');
                rightCol.appendChild(r2Input);
            }
            wrapper.appendChild(rightCol);
        }
        
        function renderHistoryItems(container, currentInput) {
            container.innerHTML = '';
            const allInputs = Array.from(document.querySelectorAll('.input-box'));
            const usedNames = allInputs.filter(el => el !== currentInput && el.value.trim() !== "").map(el => el.value.trim());
            const validItems = historyList.slice().reverse().filter(name => !usedNames.includes(name));

            if (validItems.length === 0) return 0;

            validItems.forEach(name => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerText = name;
                item.onclick = (e) => {
                    e.stopPropagation();
                    currentInput.value = name;
                    container.classList.remove('show');
                };
                let pressTimer;
                const startPress = () => {
                    pressTimer = setTimeout(() => {
                        if(confirm('Delete "' + name + '"?')) {
                            deleteHistory(name);
                            const count = renderHistoryItems(container, currentInput);
                            if(count === 0) container.classList.remove('show');
                        }
                    }, 800);
                    item.classList.add('deleting');
                };
                const endPress = () => { clearTimeout(pressTimer); item.classList.remove('deleting'); };
                item.addEventListener('mousedown', startPress);
                item.addEventListener('touchstart', startPress);
                item.addEventListener('mouseup', endPress);
                item.addEventListener('touchend', endPress);
                item.addEventListener('mouseleave', endPress);
                container.appendChild(item);
            });
            return validItems.length;
        }

        function createInput(idSuffix, placeholder) {
            const container = document.createElement('div');
            container.className = 'input-wrapper';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'input-box';
            input.id = 'input-' + idSuffix;
            input.readOnly = true; 
            input.placeholder = placeholder;
            input.autocomplete = 'off';
            input.oninput = function() { validateNameInput(this); };
            
            const historyDropdown = document.createElement('div');
            historyDropdown.className = 'history-dropdown';
            historyDropdown.id = 'history-' + idSuffix;
            
            const kbIcon = document.createElement('div');
            kbIcon.className = 'kb-icon';
            kbIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/></svg>'; 
            
            input.addEventListener('click', (e) => {
                e.stopPropagation();
                const count = renderHistoryItems(historyDropdown, input);
                if (count > 0) {
                    document.querySelectorAll('.kb-icon').forEach(i => i.classList.remove('show'));
                    kbIcon.classList.add('show');
                    document.querySelectorAll('.history-dropdown').forEach(el => el.classList.remove('show'));
                    historyDropdown.classList.add('show');
                } else {
                    document.querySelectorAll('.kb-icon').forEach(i => i.classList.remove('show'));
                    kbIcon.classList.add('show');
                    input.readOnly = false;
                    input.focus();
                    document.querySelectorAll('.history-dropdown').forEach(el => el.classList.remove('show'));
                }
            });

            kbIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                input.readOnly = false;
                input.focus();
            });
            
            container.appendChild(input);
            container.appendChild(kbIcon);
            container.appendChild(historyDropdown);
            return container;
        }
        
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.input-wrapper')) {
                document.querySelectorAll('.input-box').forEach(el => el.readOnly = true);
                document.querySelectorAll('.kb-icon').forEach(el => el.classList.remove('show'));
                document.querySelectorAll('.history-dropdown').forEach(el => el.classList.remove('show'));
            }
        });

        function saveToHistory(name) {
            if (!name || name.trim() === "" || name.startsWith("Player") || name === "P1" || name === "P2") return;
            name = name.trim();
            const idx = historyList.indexOf(name);
            if (idx > -1) historyList.splice(idx, 1);
            historyList.push(name);
            if (historyList.length > 10) historyList.shift();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(historyList));
        }

        function deleteHistory(name) {
            const idx = historyList.indexOf(name);
            if (idx > -1) {
                historyList.splice(idx, 1);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(historyList));
            }
        }

        function validateNameInput(el) {
            let str = el.value;
            let weight = 0;
            let validStr = "";
            for (let i = 0; i < str.length; i++) {
                const charWeight = (str.charCodeAt(i) > 255) ? 2 : 1;
                if (weight + charWeight <= 6) {
                    weight += charWeight;
                    validStr += str[i];
                } else break;
            }
            if (str !== validStr) el.value = validStr;
        }

        function submitNames() {
            // No sound here, performed by transition
            const l1Val = document.getElementById('input-L1').value;
            const r1Val = document.getElementById('input-R1').value;
            const l1 = l1Val || "";
            const r1 = r1Val || "";
            saveToHistory(l1Val);
            saveToHistory(r1Val);

            playerNames.l1 = l1; playerNames.r1 = r1;

            if (gameMode === 'doubles') {
                const l2Val = document.getElementById('input-L2').value;
                const r2Val = document.getElementById('input-R2').value;
                playerNames.l2 = l2Val || "";
                playerNames.r2 = r2Val || "";
                saveToHistory(l2Val);
                saveToHistory(r2Val);
            } else {
                playerNames.l2 = l1; playerNames.r2 = r1;
            }
            
            nameInputScreen.style.display = 'none';
            selectScreen.style.display = 'flex';
            bodyEl.classList.add('require-landscape');
        }

        function initSystem(firstServer) {
            // Transition handles delay, this just runs logic
            selectScreen.style.display = 'none';
            requestWakeLock();
            
            currentServer = firstServer;
            scores = { left: 0, right: 0 };
            leftPositions = [1, 2]; rightPositions = [1, 2];

            areNamesVisible = gameSettings.defaultNames;
            btnNames.innerText = areNamesVisible ? "HIDE NAMES" : "SHOW NAMES";

            if (isAIMode) {
                isCamVisible = gameSettings.defaultCam;
                if(isCamVisible) {
                    bodyEl.classList.remove('mode-blackout');
                    btnCam.innerText = "HIDE CAM";
                } else {
                    bodyEl.classList.add('mode-blackout');
                    btnCam.innerText = "SHOW CAM";
                }
                btnCam.style.display = 'block';
            } else {
                isCamVisible = false;
                bodyEl.classList.add('mode-blackout');
                btnCam.style.display = 'none';
            }

            updateScoreUI('left'); updateScoreUI('right');
            updatePositionsUI(); 

            if (isAIMode) {
                loader.style.display = 'flex';
                startApp(); 
            } else { 
                startGameLoop(); 
            }
        }

        function resetScores() {
            playSound('select'); 
            scores = { left: 0, right: 0 };
            leftPositions = [1, 2]; rightPositions = [1, 2];
            cooldownTimer = 0;
            if (cooldownInterval) clearInterval(cooldownInterval);
            gameContainer.classList.remove('grayscale-mode');
            updateScoreUI('left'); updateScoreUI('right');
            updatePositionsUI();
        }
        
        function changeServerSide() {
            playSound('select'); 
            currentServer = (currentServer === 'left') ? 'right' : 'left';
            updatePositionsUI();
        }

        function toggleNames() {
            playSound('select'); 
            areNamesVisible = !areNamesVisible;
            btnNames.innerText = areNamesVisible ? "HIDE NAMES" : "SHOW NAMES";
            updatePositionsUI(); 
        }

        function exitGame() {
            // Handled by transition
            isGameActive = false; 
            if(rafId) { 
                cancelAnimationFrame(rafId);
                clearTimeout(rafId); 
            }
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            if (wakeLock !== null) {
                wakeLock.release().then(() => { wakeLock = null; });
            }
            gameContainer.style.display = 'none';
            winnerScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            scores = { left: 0, right: 0 };
            cooldownTimer = 0;
            if (cooldownInterval) clearInterval(cooldownInterval);
            gameContainer.classList.remove('grayscale-mode');
            bodyEl.classList.remove('require-landscape');
        }

        async function startApp() {
            try {
                statusText.innerText = "LOADING AI CORE...";
                tf.env().set('WEBGL_DELETE_TEXTURE_THRESHOLD', 0);
                await tf.setBackend('webgl'); await tf.ready();
                
                let constraints = {
                    audio: false,
                    video: { 
                        facingMode: 'user', 
                        width: { ideal: appSettings.width }, 
                        height: { ideal: appSettings.height } 
                    }
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.width = video.videoWidth; video.height = video.videoHeight;
                    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                    video.play(); 
                    if(isModelLoaded) { loader.style.display='none'; startGameLoop(); }
                    else loadModel();
                };
            } catch (e) { 
                alert("Camera Error: " + e.message); 
                exitGame(); 
            }
        }

        async function loadModel() {
            statusText.innerText = "CALIBRATING...";
            try {
                const model = poseDetection.SupportedModels.MoveNet;
                const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                detector = await poseDetection.createDetector(model, detectorConfig);
                isModelLoaded = true; loader.style.display = 'none'; startGameLoop();
            } catch (e) { alert("Model Error"); }
        }
        
        function startGameLoop() {
            gameContainer.style.display = 'block';
            setTimeout(() => { playSound('start'); }, 1000); 
            isGameActive = true;
            detectLoop();
            showControls();
        }

        function showControls() {
            uiLayer.classList.add('controls-visible');
            clearTimeout(controlsTimer);
            controlsTimer = setTimeout(() => {
                uiLayer.classList.remove('controls-visible');
            }, 3000);
        }
        
        ['mousemove', 'touchstart', 'click'].forEach(evt => {
            gameContainer.addEventListener(evt, showControls, {passive: true});
        });

        function manualAdjustScore(side, delta) {
            if (delta > 0) scorePoint(side);
            else {
                playSound('select'); 
                scores[side] += delta;
                if (scores[side] < 0) scores[side] = 0;
                if (delta < 0 && side === currentServer) {
                      if (gameMode === 'doubles') {
                          if (side === 'left') {
                              let temp = leftPositions[0]; leftPositions[0] = leftPositions[1]; leftPositions[1] = temp;
                          } else {
                              let temp = rightPositions[0]; rightPositions[0] = rightPositions[1]; rightPositions[1] = temp;
                          }
                      }
                      currentServer = (side === 'left' ? 'right' : 'left'); 
                }
                updateScoreUI(side); updatePositionsUI();
            }
        }

        function speakScore(side) {
            window.speechSynthesis.cancel();
            
            let text = "";
            const lName = playerNames.l1.trim();
            const rName = playerNames.r1.trim();
            
            if (side === 'left') {
                if (lName && lName.length > 0) {
                    text += lName;
                    if(gameMode === 'doubles') text += "隊";
                    text += "得分";
                } else {
                    text += "左方得分";
                }
            } else {
                if (rName && rName.length > 0) {
                    text += rName;
                    if(gameMode === 'doubles') text += "隊";
                    text += "得分";
                } else {
                    text += "右方得分";
                }
            }
            
            if (side === 'left') {
                text += `，${scores.left} 比 ${scores.right}`;
            } else {
                text += `，${scores.right} 比 ${scores.left}`;
            }

            if (gameMode === 'doubles') {
                const servingSide = currentServer; 
                const score = scores[servingSide];
                const isEven = (score % 2 === 0);

                const l1 = playerNames.l1.trim() || "左1"; 
                const l2 = playerNames.l2.trim() || "左2"; 
                const r1 = playerNames.r1.trim() || "右1"; 
                const r2 = playerNames.r2.trim() || "右2"; 

                const nameLT = leftPositions[1] === 1 ? l1 : l2;
                const nameLB = leftPositions[0] === 1 ? l1 : l2;
                const nameRT = rightPositions[0] === 1 ? r1 : r2;
                const nameRB = rightPositions[1] === 1 ? r1 : r2;

                let serverName = "";
                let receiverName = "";

                if (servingSide === 'left') {
                    if (isEven) {
                        serverName = nameLB; receiverName = nameRT;
                    } else {
                        serverName = nameLT; receiverName = nameRB;
                    }
                } else { 
                    if (isEven) {
                        serverName = nameRT; receiverName = nameLB;
                    } else {
                        serverName = nameRB; receiverName = nameLT;
                    }
                }
                text += `，${serverName}發球，${receiverName}接發球`;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = gameSettings.rate;
            utterance.volume = gameSettings.volume;
            
            const voice = getPreferredVoice();
            if (voice) utterance.voice = voice;
            else utterance.lang = 'zh-TW';

            window.speechSynthesis.speak(utterance);
        }

        function scorePoint(side) {
            handleScorePoint(side);
            
            // 播放得分音效
            playSound(side === 'left' ? 'red' : 'blue');
            
            // 延遲2秒後播報
            setTimeout(() => { speakScore(side); }, 2000);
            
            const color = side === 'left' ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 0, 255, 0.5)';
            ctx.fillStyle = color; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (checkWinner(side)) return;
            startCooldown(COOLDOWN_DURATION);
        }

        function handleScorePoint(winningSide) {
            if (gameMode === 'doubles') {
                if (winningSide === currentServer) {
                    if (winningSide === 'left') {
                        let temp = leftPositions[0]; leftPositions[0] = leftPositions[1]; leftPositions[1] = temp;
                    } else {
                        let temp = rightPositions[0]; rightPositions[0] = rightPositions[1]; rightPositions[1] = temp;
                    }
                }
            }
            scores[winningSide]++;
            currentServer = winningSide;
            updateScoreUI(winningSide);
            updatePositionsUI();
        }

        function updatePositionsUI() {
            // 重置所有邊條
            Object.values(bars).forEach(bar => { 
                bar.className = 'side-bar'; 
                bar.style.removeProperty('background-color');
                bar.style.boxShadow = 'none';
            });
            Object.values(nameLabels).forEach(lbl => { lbl.innerText = ""; lbl.classList.remove('name-visible'); });

            const score = scores[currentServer];
            const isEven = (score % 2 === 0);
            updateArrow();

            const cRed = 'var(--color-1p-main)';
            const cBlue = 'var(--color-2p-main)';

            if (gameMode === 'doubles') {
                // 左方：上紅 下藍
                bars.lt.style.backgroundColor = cRed;
                bars.lb.style.backgroundColor = cBlue;
                // 右方：上藍 下紅
                bars.rt.style.backgroundColor = cBlue;
                bars.rb.style.backgroundColor = cRed;
            } else {
                // 單打：依照隊伍顏色
                bars.lt.style.backgroundColor = cRed;
                bars.lb.style.backgroundColor = cRed;
                bars.rt.style.backgroundColor = cBlue;
                bars.rb.style.backgroundColor = cBlue;
            }

            if (isEven) {
                // 偶數分：發球/接發在 [左下] 與 [右上]
                bars.lb.classList.add('bar-active');
                bars.rt.classList.add('bar-active');
                
                if (gameMode === 'doubles') { 
                    bars.lt.classList.add('bar-partner'); 
                    bars.rb.classList.add('bar-partner'); 
                }
            } else {
                // 奇數分：發球/接發在 [左上] 與 [右下]
                bars.lt.classList.add('bar-active');
                bars.rb.classList.add('bar-active');
                
                if (gameMode === 'doubles') { 
                    bars.lb.classList.add('bar-partner'); 
                    bars.rt.classList.add('bar-partner'); 
                }
            }

            let nameLT = "", nameLB = "", nameRT = "", nameRB = "";
            if (gameMode === 'singles') {
                if (isEven) nameLB = playerNames.l1; else nameLT = playerNames.l1;
                if (isEven) nameRT = playerNames.r1; else nameRB = playerNames.r1;
            } else {
                nameLT = leftPositions[1] === 1 ? playerNames.l1 : playerNames.l2;
                nameLB = leftPositions[0] === 1 ? playerNames.l1 : playerNames.l2;
                nameRT = rightPositions[0] === 1 ? playerNames.r1 : playerNames.r2;
                nameRB = rightPositions[1] === 1 ? playerNames.r1 : playerNames.r2;
            }

            if (areNamesVisible) {
                if(nameLT) { nameLabels.lt.innerText = nameLT; nameLabels.lt.classList.add('name-visible'); }
                if(nameLB) { nameLabels.lb.innerText = nameLB; nameLabels.lb.classList.add('name-visible'); }
                if(nameRT) { nameLabels.rt.innerText = nameRT; nameLabels.rt.classList.add('name-visible'); }
                if(nameRB) { nameLabels.rb.innerText = nameRB; nameLabels.rb.classList.add('name-visible'); }
            }
        }

        function updateArrow() {
            arrowSvg.setAttribute('class', '');
            if (currentServer === 'left') arrowSvg.setAttribute('class', 'svg-arrow-left');
            else arrowSvg.setAttribute('class', 'svg-arrow-right');
        }

        function checkWinner(side) {
            const my = scores[side]; const op = scores[side==='left'?'right':'left'];
            let isWin = false;
            if (my >= WIN_SCORE) { if (my - op >= 2) isWin = true; }
            if (my === MAX_SCORE) isWin = true;
            if (isWin) { showWinner(side); return true; }
            return false;
        }
        function showWinner(side) {
            isGameActive = false; if(rafId) { cancelAnimationFrame(rafId); clearTimeout(rafId); }
            const wName = side==='left' ? playerNames.l1 : playerNames.r1; 
            winnerText.innerText = wName + "\nWIN!";
            winnerText.style.color = side==='left'?'var(--color-1p-light)':'var(--color-2p-light)';
            setTimeout(()=>{gameContainer.style.display='none';winnerScreen.style.display='flex';},1000);
        }
        function updateScoreUI(side) {
            const el = document.getElementById(`score-${side}`); el.innerText = scores[side];
            if(scores[side]>0) el.classList.add('has-score'); else el.classList.remove('has-score');
            el.classList.remove('score-pop'); void el.offsetWidth; el.classList.add('score-pop');
        }
        function toggleCamera() {
            if (!isAIMode) return;
            playSound('select'); 
            isCamVisible = !isCamVisible;
            if (isCamVisible) { bodyEl.classList.remove('mode-blackout'); btnCam.innerText = "HIDE CAM"; }
            else { bodyEl.classList.add('mode-blackout'); btnCam.innerText = "SHOW CAM"; }
        }
        function startCooldown(t) {
            cooldownTimer = t || COOLDOWN_DURATION;
            gameContainer.classList.add('grayscale-mode');
            if(cooldownInterval) clearInterval(cooldownInterval);
            const start = Date.now(); const total = cooldownTimer*1000;
            cooldownInterval = setInterval(()=>{
                const left = total - (Date.now()-start); cooldownTimer = left/1000;
                if(cooldownTimer<=0) { 
                    clearInterval(cooldownInterval); 
                    cooldownTimer=0; 
                    gameContainer.classList.remove('grayscale-mode');
                }
            },50);
        }
        function setupSwipeControl(id, side) {
            const el = document.getElementById(id); let sY=0;
            el.addEventListener('touchstart',e=>{sY=e.touches[0].clientY},{passive:true});
            el.addEventListener('touchend',e=>{
                if(Math.abs(sY - e.changedTouches[0].clientY)>50) manualAdjustScore(side, sY > e.changedTouches[0].clientY ? 1 : -1);
            },{passive:true});
            el.addEventListener('mousedown',e=>{sY=e.clientY});
            el.addEventListener('mouseup',e=>{
                if(Math.abs(sY - e.clientY)>50) manualAdjustScore(side, sY > e.clientY ? 1 : -1);
            });
        }
        setupSwipeControl('group-left','left'); setupSwipeControl('group-right','right');

        async function detectLoop() {
            if(!isGameActive) return;
            setTimeout(() => { rafId = requestAnimationFrame(runDetection); }, 1000 / appSettings.fps); 
        }

        async function runDetection() {
             if(!isGameActive) return;
             
             if(isAIMode && video.readyState>=2) {
                try {
                    const poses = await detector.estimatePoses(video);
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    if(cooldownTimer<=0) {
                        if(gameContainer.classList.contains('grayscale-mode')) gameContainer.classList.remove('grayscale-mode');
                        if(poses.length>0 && poses[0].score>0.3) {
                            checkGameLogic(poses[0].keypoints);
                        } else resetHold();
                    }
                } catch(e){ console.error(e); return; }
            } else { ctx.clearRect(0,0,canvas.width,canvas.height); }
            detectLoop();
        }

        function checkGameLogic(kp) {
            const midX = canvas.width/2;
            const lw = kp.find(k=>k.name==='left_wrist'); const rw = kp.find(k=>k.name==='right_wrist');
            let active = null;
            if(lw && lw.score>0.3 && lw.y < kp.find(k=>k.name==='left_ear').y) active=lw;
            else if(rw && rw.score>0.3 && rw.y < kp.find(k=>k.name==='right_ear').y) active=rw;
            if(!active) { resetHold(); return; }
            
            const side = (active.name === 'left_wrist') ? 'left' : 'right';
            
            if(!isHolding) { isHolding=true; holdStart=Date.now(); }
            else {
                if(!isHolding) { smoothX = active.x; smoothY = active.y; }
                smoothX += (active.x - smoothX) * 0.2;
                smoothY += (active.y - smoothY) * 0.2;
                const prog = Math.min((Date.now()-holdStart)/HOLD_DURATION, 1);
                drawHoldRing(smoothX, smoothY, prog, side);
                if(prog>=1) { scorePoint(side); resetHold(); }
            }
        }
        function resetHold(){ isHolding=false; holdStart=0; }
        
        function drawHoldRing(x,y,p,side) {
            const c = side==='left'?'#D32F2F':'#1976D2';
            ctx.save();
            ctx.translate(x, y);
            
            ctx.beginPath(); 
            ctx.rect(-50, -50, 100, 100); 
            ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=4; ctx.stroke();
            
            const height = 100 * p;
            ctx.fillStyle = c;
            ctx.fillRect(-46, 46 - height, 92, height);
            
            ctx.restore();
        }

        document.addEventListener('dblclick',e=>{
            if(e.target.tagName!=='BUTTON' && e.target.tagName!=='INPUT' && !e.target.closest('.select-zone') && !e.target.closest('.switch') && !e.target.closest('.history-dropdown') && !e.target.closest('.settings-control') && !e.target.closest('#settings-modal')) {
                if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen();
            }
        });
    </script>
</body>
</html>
